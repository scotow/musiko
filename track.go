package musiko

import (
	"github.com/grafov/m3u8"
	"github.com/pkg/errors"
	"io"
	"io/ioutil"
	"net/http"
	"os"
)

var (
	ErrAPIStatusCode     = errors.New("api responded with a non 200")
	ErrWrongPlaylistType = errors.New("ffmpeg returns invalid m3u8 file")
)

var (
	httpClient *http.Client
)

func NewTrack(url string) *Track {
	return &Track{
		url: url,
	}
}

type Track struct {
	url string

	playlist m3u8.Playlist
}

func (t *Track) Open() (io.Reader, error) {
	resp, err := httpClient.Get(t.url)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		return nil, ErrAPIStatusCode
	}

	return resp.Body, nil
}

func (t *Track) GetData() ([]byte, error) {
	r, err := t.Open()
	if err != nil {
		return nil, err
	}

	data, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	return data, nil
}

func (t *Track) SplitTS() (m3u8.Playlist, error) {
	if t.playlist != nil {
		return t.playlist, nil
	}

	r, err := t.Open()
	if err != nil {
		return nil, err
	}

	dest := os.TempDir()
	playlistPath, err := FfmpegSplitTS(r, dest)
	if err != nil {
		return nil, err
	}

	playlistFile, err := os.Open(playlistPath)
	if err != nil {
		return nil, err
	}

	// Parse m3u8 file generated by ffmpeg.
	playlist, playlistType, err := m3u8.DecodeFrom(playlistFile, true)
	if err != nil {
		return nil, err
	}

	// Close m3u8 file.
	err = playlistFile.Close()
	if err != nil {
		return nil, err
	}

	if playlistType != m3u8.MEDIA {
		return nil, ErrWrongPlaylistType
	}

	// Cache playlist.
	t.playlist = playlist

	return playlist, nil
}
