package musiko

import (
	"bytes"
	"github.com/google/uuid"
	"github.com/grafov/m3u8"
	"github.com/pkg/errors"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
)

var (
	ErrAPIStatusCode     = errors.New("api responded with a non 200")
	ErrWrongPlaylistType = errors.New("ffmpeg returns invalid m3u8 file")
	ErrSplitMismatch     = errors.New("Playlist and parts mismatch")
)

type TrackInfo struct {
	Artist string `json:"artist"`
	Album  string `json:"album"`
	Name   string `json:"name"`
}

func NewTrack(url string, info TrackInfo, httpClient *http.Client) *Track {
	t := new(Track)
	t.id = uuid.New()
	t.url = url
	t.info = info
	t.httpClient = httpClient

	return t
}

type Track struct {
	id   uuid.UUID
	url  string
	info TrackInfo

	data       []byte
	httpClient *http.Client

	playlist *m3u8.MediaPlaylist
	parts    []*Part
	queue    []*Part
}

func (t *Track) Open() (io.Reader, error) {
	resp, err := t.httpClient.Get(t.url)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		return nil, ErrAPIStatusCode
	}

	return resp.Body, nil
}

func (t *Track) GetData() ([]byte, error) {
	if t.data != nil {
		return t.data, nil
	}

	r, err := t.Open()
	if err != nil {
		return nil, err
	}

	data, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	t.data = data
	return data, nil
}

func (t *Track) ClearData() {
	t.data = nil
}

// TODO: Use defer to remove parts on error.
func (t *Track) GetParts() (*m3u8.MediaPlaylist, []*Part, error) {
	if t.playlist != nil && t.parts != nil {
		return t.playlist, t.parts, nil
	}

	data, err := t.GetData()
	if err != nil {
		return nil, nil, err
	}

	tmp, err := ioutil.TempDir("", "musiko")
	if err != nil {
		return nil, nil, err
	}

	playlistPath, err := FfmpegSplitTS(bytes.NewBuffer(data), tmp)
	if err != nil {
		return nil, nil, err
	}

	playlistFile, err := os.Open(playlistPath)
	if err != nil {
		return nil, nil, err
	}

	// Parse m3u8 file generated by ffmpeg.
	playlist, playlistType, err := m3u8.DecodeFrom(playlistFile, true)
	if err != nil {
		return nil, nil, err
	}

	// Close m3u8 file.
	err = playlistFile.Close()
	if err != nil {
		return nil, nil, err
	}

	if playlistType != m3u8.MEDIA {
		return nil, nil, ErrWrongPlaylistType
	}

	// Cast and cache playlist.
	playlistMedia := playlist.(*m3u8.MediaPlaylist)
	parts := make([]*Part, 0, len(playlistMedia.Segments))

	for _, seg := range playlistMedia.Segments {
		if seg == nil {
			break
		}

		partData, err := ioutil.ReadFile(path.Join(tmp, seg.URI))
		if err != nil {
			return nil, nil, err
		}

		parts = append(parts, &Part{partData, seg})
	}

	if uint(len(parts)) != playlistMedia.Count() {
		return nil, nil, ErrSplitMismatch
	}

	err = os.RemoveAll(tmp)
	if err != nil {
		return nil, nil, err
	}

	t.playlist = playlistMedia
	t.parts = parts
	t.queue = parts

	return playlistMedia, parts, nil
}

func (t *Track) slide() bool {
	if len(t.queue) == 0 {
		return true
	}

	t.queue = t.queue[1:]
	return len(t.queue) == 0
}
