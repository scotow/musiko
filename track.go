package musiko

import (
	"bytes"
	"github.com/google/uuid"
	"github.com/grafov/m3u8"
	"github.com/pkg/errors"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
)

var (
	ErrAPIStatusCode     = errors.New("api responded with a non 200")
	ErrWrongPlaylistType = errors.New("ffmpeg returns invalid m3u8 file")
	ErrSplitMismatch     = errors.New("Playlist and parts mismatch")
)

func NewTrack(url string, httpClient *http.Client) *Track {
	t := new(Track)
	t.id = uuid.New()
	t.url = url
	t.httpClient = httpClient

	return t
}

type Track struct {
	id         uuid.UUID
	url        string
	data       []byte
	httpClient *http.Client

	playlist *m3u8.MediaPlaylist
	parts    [][]byte
}

func (t *Track) Open() (io.Reader, error) {
	resp, err := t.httpClient.Get(t.url)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		return nil, ErrAPIStatusCode
	}

	return resp.Body, nil
}

func (t *Track) GetData() ([]byte, error) {
	if t.data != nil {
		return t.data, nil
	}

	r, err := t.Open()
	if err != nil {
		return nil, err
	}

	data, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	t.data = data
	return data, nil
}

// TODO: Use defer to remove parts on error.
func (t *Track) GetParts() (*m3u8.MediaPlaylist, [][]byte, error) {
	if t.playlist != nil && t.parts != nil {
		return t.playlist, t.parts, nil
	}

	data, err := t.GetData()
	if err != nil {
		return nil, nil, err
	}

	tmp, err := ioutil.TempDir("", "musiko")
	if err != nil {
		return nil, nil, err
	}

	playlistPath, err := FfmpegSplitTS(bytes.NewBuffer(data), tmp)
	if err != nil {
		return nil, nil, err
	}

	playlistFile, err := os.Open(playlistPath)
	if err != nil {
		return nil, nil, err
	}

	// Parse m3u8 file generated by ffmpeg.
	playlist, playlistType, err := m3u8.DecodeFrom(playlistFile, true)
	if err != nil {
		return nil, nil, err
	}

	// Close m3u8 file.
	err = playlistFile.Close()
	if err != nil {
		return nil, nil, err
	}

	if playlistType != m3u8.MEDIA {
		return nil, nil, ErrWrongPlaylistType
	}

	// Cast and cache playlist.
	playlistMedia := playlist.(*m3u8.MediaPlaylist)
	parts := make([][]byte, 0, len(playlistMedia.Segments))

	for _, seg := range playlistMedia.Segments {
		if seg == nil {
			break
		}

		part, err := ioutil.ReadFile(path.Join(tmp, seg.URI))
		if err != nil {
			return nil, nil, err
		}

		parts = append(parts, part)
	}

	if uint(len(parts)) != playlistMedia.Count() {
		return nil, nil, ErrSplitMismatch
	}

	err = os.RemoveAll(tmp)
	if err != nil {
		return nil, nil, err
	}

	t.playlist = playlistMedia
	t.parts = parts

	return playlistMedia, parts, nil
}

/*func (t *Track) SplitTS(dest string, keepM3u8 bool) (*m3u8.MediaPlaylist, error) {
	if t.playlist != nil {
		return t.playlist, nil
	}

	r, err := t.Open()
	if err != nil {
		return nil, err
	}

	playlistPath, err := FfmpegSplitTS(r, dest)
	if err != nil {
		return nil, err
	}

	playlistFile, err := os.Open(playlistPath)
	if err != nil {
		return nil, err
	}

	// Parse m3u8 file generated by ffmpeg.
	playlist, playlistType, err := m3u8.DecodeFrom(playlistFile, true)
	if err != nil {
		return nil, err
	}

	// Close m3u8 file.
	err = playlistFile.Close()
	if err != nil {
		return nil, err
	}

	if !keepM3u8 {
		err = os.Remove(playlistPath)
		if err != nil {
			return nil, err
		}
	}

	if playlistType != m3u8.MEDIA {
		return nil, ErrWrongPlaylistType
	}

	// Cast and cache playlist.
	t.playlist = playlist.(*m3u8.MediaPlaylist)

	return t.playlist, nil
}*/
